{% extends '../blog-post.twig' %}

{% block content %}
    <div class="container u-maxWidth740">
        <h1>Terraform for Serverless Series: Enhanced Management of AWS Fargate Tasks</h1>
        <p class="graf-gray">October 19th, 2018 / 5 min read </p>
        <p class="graf graf-up">
            Couple of weeks ago I started Terraform for Serverless Series by describing <a href="https://www.terrahub.io/blog/terraform-for-serverless-series-enhanced-management-of-aws-lambda-functions/">Enhanced Management of AWS Lambda Functions</a>. A week later, I dived deeper into <a href="https://www.terrahub.io/blog/terraform-for-serverless-series-enhanced-management-of-amazon-s3-websites/">Enhanced Management of Amazon S3 Websites</a>. Today I would like to continue this blog posts series with another service: AWS Fargate.
        </p>
        <p class="graf graf-up">
            According to official website AWS Fargate is a compute engine for Amazon ECS that allows you to run containers without having to manage servers or clusters. In other words, it is a serverless implementation of containers on AWS. In this article I will provide some magic around how to build terraform configurations that provision and deploy serverless containers.
        </p>
        <p class="graf graf-up">
            So, let's get started.
        </p>
        <h3>Terraform for Amazon ECS</h3>
        <p class="graf graf-up">
            Similar to previous blog posts, it should go without saying (or at least stated up front): My personal preference is to separate terraform configurations into group / type / service / function specific .tf files. So, normally, I would define my providers in provider.tf, setup my data in data.tf, specify my variables in variables.tf, configure my resources in main.tf and so on. But, for the purpose of this article, I'm putting everything all together into one single .tf file, ignoring best practices as long as it works:
        </p>
        <script src="https://gist.github.com/eistrati/a172bd5102f5c3353acb250ab643fcfd.js"></script>
        <p class="graf graf-up">
            For simplicity, I chose to use default Subnets linked to default VPC. When the ECS service is created, all subnets are used as part of network_configuration. Also, the cluster is setup with no extra fine tuning. There is no need to create a new cluster if you already have one. Last, but not the least, container's task definition referenced in the code above is stored in <span class="italic">task-definitions</span> folder, <span class="italic">application.json</span> file and looks like this:
        </p>
        <pre><code class="html">
 [{
  "name": "${ecs_name}",
  "image": "${ecs_image}",
  "cpu": ${ecs_cpu},
  "memory": ${ecs_memory},
  "essential": true,
  "networkMode": "awsvpc",
  "portMappings": [{
    "containerPort": ${ecs_port},
    "hostPort": ${app_port}
  }]
}]
        </code></pre>
        <p class="graf graf-grap">
            Every time when I update my task definition, terraform will update my AWS Fargate task. But what happens when I update my image? Specifically, will my serverless container be updated as well? It depends. The answer is yes if you publish it as latest, otherwise the answer is no. Luckily, we are developers and can do something about it.
        </p>
        <h3>Terraform for Container Builder</h3>
        <p class="graf graf-up">
            I am excited to introduce terraform for containers building process.
        </p>
        <h3>Still Needs Improvements</h3>
        <p class="graf graf-up">Unfortunately, above code is not perfect. We are aware of the following issues:</p>
        <ul class="graf graf--li graf-grap">
            <li>
                <span class="italic">build.sh</span> will be executed at every terraform plan action (as well as apply or destroy if plan is not passed as input variable); we are working to optimize it and improve it by checking if any file in <span class="italic">build_path</span> was recently changed in comparison with timestamp of corresponding file (or files) in <span class="italic">s3_path</span>
            </li>
            <li>
                this implementation triggers builds on <span class="italic">timestamp</span>; we are working to optimize and improve it by comparing the timestamp of previous build with triggers value generated by terraform
            </li>
        </ul>
        <p class="graf graf-grap">
            <span class="italic">Spoiler Alert:</span> all steps and work-arounds described in this article are carefully crafted into language agnostic functionality that will be released soon as a new feature in our open source project <a href="https://github.com/TerraHubCorp/terrahub" alt="TerraHub on GitHub" target="_blank" rel="noreferrer">TerraHub CLI</a>.
        </p>
        <p class="graf graf-grap">
            We would love to hear thoughts and comments on what could be done better.
        </p>
    </div>


    <div class="container u-maxWidth740">
        <h4>Final Thoughts</h4>
        <p class="graf graf-up">
            TerraHub.io is the DevOps Hub for Terraform Automation. We provide managed services
            that simplify cloud resources management using terraform. If this is of your interest
            and you'd like to learn more, please feel free to reach out over
            <a href="mailto:hello@terrahub.io" target="_blank" rel="noopener">Email</a>,
            <a href="https://twitter.com/terrahubcorp" alt="TerraHub on Twitter" target="_blank" rel="noreferrer">Twitter</a> or
            <a href="https://www.linkedin.com/company/terrahubcorp" alt="TerraHub on LinkedIn" target="_blank" rel="noreferrer">LinkedIn</a>.
            We'd be happy to help!
        </p>
    </div>

{% endblock %}
